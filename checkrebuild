#!/bin/bash
#
# Detect broken packages that need to be rebuilt
# vim: ts=4 sw=4 et

shopt -s nullglob
shopt -s extglob
[ -t 1 ] && declare _terminal_output=1
[ -t 0 ] || mapfile -t _hook_targets

log="$(mktemp -d)"
touch "$log/resolved_symbols"
trap 'rm -rf "$log"' EXIT

verbose=0
while getopts "vai:" OPTION; do
    case $OPTION in
        a) system=1 ;;
        v) ((verbose+=1)) ;;
        i) include+=("$OPTARG") ;;
        *) exit 1 ;;
    esac
done

get_unofficial_pkgs() {
    if ((system)); then
        pacman -Qq
    else
        mapfile -t local_enabled_repos < <(for repo in $(pacconf --repo-list); do pacconf --repo="$repo" Server|grep -q "file://" || [[ "${include[*]}" =~ $repo ]] || echo "$repo"; done)
        if [[ -v _hook_targets[@] ]]; then
            ( IFS=$'\n'; xargs -I{} pactree -rud1 {}<<<"${_hook_targets[*]}"|sort -u)
        else
            pacman -Qq
        fi|sort|comm -23 - <(eval pacman -Sql "${local_enabled_repos[*]}" 2>/dev/null | sort)
    fi
}

get_package_files() {
    xargs pacman -Qql |
    perl -pe 's/\n/\0/' |
    xargs -0 -I{} readlink -f "{}" |
    sort -u
}

filter_executable() {
    while read -r file; do
        [[ -f "$file" && -x "$file" ]] && file "$file"|grep -q ELF && echo "$file"
    done
}

ldd_detect_broken_files() {
    declare -a files
    declare -A resolved_symbols
    declare -A unresolved_symbols
    mapfile -t files < <(cat)
    resolve_symbol_cache() {
    #args: $1: name of the missing symbols variable (string|array).
    #      $2: name of scanelf resolve variable (string).
    #      $3: name of output array.
            #clear output variable
            eval 'unset '"$3"
            for symbol in $(eval echo '${'"$1"'[*]}'); do
                if scanelf_resolve_symbol=$(eval 'grep -oP "$symbol.*  \K.*" <<<$'"$2"); then
                    resolved_symbols+=(["$symbol"]="$scanelf_resolve_symbol")
                else
                    eval "$3"'+=("$symbol")'
                fi
            done
    }
    for file in "${files[@]}"; do
        ldd_resolve=$(ldd -r "$file" 2>/dev/null)
        if missing_shared_objects=$(grep -oP "(?<=\t).*?(?= => not found)" <<<"$ldd_resolve"); then
            for shared_object in $missing_shared_objects; do
                if shared_object_resolve=$(grep -oP "[^ ]*$shared_object"<<<"${files[*]}"); then
                    resolved_shared_objects+=("$shared_object_resolve")
                else
                    unresolved_shared_objects+=("$shared_object")
                fi
            done
            if [ -v unresolved_shared_objects ]; then
                pkg=$(pacman -Qqo "$file")
                (( verbose )) && echo -e "$pkg: $file\nunresolved shared objects: ${unresolved_shared_objects[*]}" >&2
                echo "$pkg"
                return 0
            fi
        fi
        #update $ldd_resolve with $resolved_shared_objects.
        if [[ -v resolved_shared_objects[@] ]]; then
            library_path=$(IFS=$'\n'; sort -u<<<"${resolved_shared_objects[*]%/*}"|paste -sd ':')
            ldd_resolve=$(LD_LIBRARY_PATH="$library_path" ldd -r "$file" 2>/dev/null)
        fi
        #drop symbol version, not supported by `scanelf`
        if ! undefined_symbols=$(grep -oP "undefined symbol: \K.*?(?=[\t,])" <<<"$ldd_resolve"); then
            continue
        else
            #report $files as broken if depends on unresolved symbol.
            if [[ -s "$log/resolved_symbols" ]]; then
                flock -s "$log/resolved_symbols" -c "source $log/resolved_symbols"
            fi
            if [[ -v unresolved_symbols[@] ]] && known_unresolved_symbols=$(grep -f <(IFS=$'\n'; echo "${!unresolved_symbols[*]}") <<<"$undefined_symbols"); then
                pkg=$(pacman -Qqo "$file")
                (( verbose )) && echo -e "$pkg: $file\n(cached)unresolved symbols: $known_unresolved_symbols" >&2
                echo "$pkg"
                return 0
            fi
            #drop cached symbols.
            if [[ -v resolved_symbols[@] ]]; then
                undefined_symbols=$(grep -v -f <(IFS=$'\n'; echo "${!resolved_symbols[*]}") <<<"$undefined_symbols")
            fi
            #skip if all symbols in cache.
            [[ -z "$undefined_symbols" ]] && continue
            #package wide symbol resolution.
            scanelf_resolve=$(scanelf -qs "+$(tr $'\n' ','<<<"$undefined_symbols"|sed -e 's/,$//' -e 's/,/,\+/g')" "${files[@]}"|grep -f <(echo "${undefined_symbols}"))
            if [ -n "$scanelf_resolve" ]; then
                resolve_symbol_cache undefined_symbols scanelf_resolve local_unresolved_symbols
            else
                mapfile -t local_unresolved_symbols <<<"$undefined_symbols"
            fi
        fi
        if [ -v local_unresolved_symbols ]; then
            #system wide symbol resolution.
            scanelf_resolve=$(scanelf -qpls "+$(IFS=','; echo "${local_unresolved_symbols[*]}"|sed -e 's/,$//' -e 's/,/,\+/g')"|grep -f <(IFS=$'\n'; echo "${local_unresolved_symbols[*]}"))
            if [ -n "$scanelf_resolve" ]; then
                resolve_symbol_cache local_unresolved_symbols scanelf_resolve system_wide_unresolved_symbols
            else
                mapfile -t system_wide_unresolved_symbols <<<"$local_unresolved_symbols"
            fi
            if [ -v system_wide_unresolved_symbols ]; then
            #do a deep search.
            scanelf_resolve=$(scanelf -qRs "+$(IFS=','; echo "${system_wide_unresolved_symbols[*]}"|sed -e 's/,$//' -e 's/,/,\+/g')" /usr/{bin,lib}|grep -f <(IFS=$'\n'; echo "${system_wide_unresolved_symbols[*]}"))
            [ -n "$scanelf_resolve" ] && resolve_symbol_cache system_wide_unresolved_symbols scanelf_resolve deep_unresolved_symbols
            fi
            if [ -v deep_unresolved_symbols ]; then
                pkg=$(pacman -Qqo "$file")
                (( verbose )) && echo -e "$pkg: $file\nunresolved symbols: ${deep_unresolved_symbols[*]}" >&2
                #cache unresolved symbols
                for symbol in ${deep_unresolved_symbols[*]}; do
                    unresolved_symbols+=(["$symbol"]="$file")
                done
                echo "$pkg"
                return 0
            fi
        fi
    done
    if [[ -v resolved_symbols[@] ]]; then
        resolved_symbols_declaration=$(declare -p resolved_symbols)
        eval declare -A "resolved_symbols_copy=${resolved_symbols_declaration#*=}"
        exec {cache}<"$log/resolved_symbols"
        flock -x "$cache"
        resolved_symbols=()
        source "$log/resolved_symbols"
        mapfile -t new_symbols < <(comm -23 <(IFS=$'\n'; echo "${!resolved_symbols_copy[*]}"|sort) <(IFS=$'\n'; echo "${!resolved_symbols[*]}"|sort))
        if [[ -v new_symbols[@] ]]; then
            for symbol in ${new_symbols[*]}; do
                resolved_symbols+=(["$symbol"]="${resolved_symbols_copy["$symbol"]}")
            done
            declare -p resolved_symbols > "$log/resolved_symbols"
        fi
        exec {cache}<&-
    fi
}

get_broken_ldd_pkgs() {
    export -f get_package_files
    export -f filter_executable
    export -f ldd_detect_broken_files
    export log verbose
    get_unofficial_pkgs |
    parallel ${_terminal_output:+--bar}  --will-cite --joblog "$log/rebuild-detector-parallel.log" "echo {}|get_package_files|filter_executable|ldd_detect_broken_files"
}

get_broken_python_pkgs() {
    command -v python >/dev/null || return
    python_version="$(python3 -c 'import sys; print (sys.version_info.minor)')"
    pacman -Qqo /usr/lib/python3.!("$python_version") 2>/dev/null
}

get_broken_perl_pkgs() {
    command -v perl >/dev/null || return
    perl_version="$(perl -E 'say $^V =~ /(\d+[.]\d+)/')"
    pacman -Qqo /usr/lib/perl*/!("$perl_version") 2>/dev/null
}

get_broken_pkgs() {
    {
        get_broken_ldd_pkgs
        get_broken_python_pkgs
        get_broken_perl_pkgs
    } | sort -u
}

get_repo_pkgs() {
    pacman -Sl | cut -d' ' -f1-2
    pacman -Qqm | awk '{print "foreign", $0}'
}

join -12 <(get_repo_pkgs | sort -k2) <(get_broken_pkgs) | awk '{ print $2 "\t" $1 }'

if (( verbose>1 )); then
    sort -k4 -n "$log/rebuild-detector-parallel.log"
fi

exit 0
