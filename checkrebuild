#!/bin/bash
#
# Detect broken packages that need to be rebuilt
# vim: ts=4 sw=4 et

shopt -s nullglob
shopt -s extglob
[ -t 1 ] && declare _terminal_output=1

log="$(mktemp -d)"
trap 'rm -rf "$log"' EXIT

verbose=0
while getopts "v" OPTION; do
    case $OPTION in
        v) verbose=1 ;;
        *) exit 1 ;;
    esac
done

get_unofficial_pkgs() {
    local_enabled_repos="$(pacconf --repo-list|paste -sd ' ' -)"
    comm -23 <(pacman -Qq | sort) <(eval pacman -Sql "$local_enabled_repos" 2>/dev/null | sort)
}

get_package_files() {
    xargs pacman -Qql |
    perl -pe 's/\n/\0/' |
    xargs -0 -I{} readlink -f "{}" |
    sort -u
}

filter_executable() {
    while read -r file; do
        [[ -f "$file" && -x "$file" ]] && file "$file"|grep -q ELF && echo "$file"
    done
}

ldd_detect_broken_files() {
    log="$log/$RANDOM"
    declare -a files
    declare -A resolved_symbols
    mapfile -t files < <(cat)
    for file in "${files[@]}"; do
        ldd_resolve=$(ldd -r "$file" 2>/dev/null)
        if missing_shared_objects=$(grep -oP "(?<=\t).*?(?= => not found)" <<<"$ldd_resolve"); then
            for shared_object in $missing_shared_objects; do
                if shared_object_resolve=$(grep -oP "[^ ]*$shared_object"<<<"${files[*]}"); then
                    resolved_shared_objects+=("$shared_object_resolve")
                else
                    unresolved_shared_objects+=("$shared_object")
                fi
            done
            if [ -v unresolved_shared_objects ]; then
                echo -e "\nldd $file\nunresolved shared objects: ${unresolved_shared_objects[*]}" >> "$log"
                echo -e "\nldd $file\nunresolved shared objects: ${unresolved_shared_objects[*]}" >&2
                pacman -Qqo "$file"
                return 0
            fi
        fi
        #update $ldd_resolve with $resolved_shared_objects.
        if [[ -v resolved_shared_objects[@] ]]; then
            library_path=$(IFS=$'\n'; sort -u<<<"${resolved_shared_objects[*]%/*}"|paste -sd ':')
            ldd_resolve=$(LD_LIBRARY_PATH="$library_path" ldd -r "$file" 2>/dev/null)
        fi
        #drop symbol version, not supported by `scanelf`
        if undefined_symbols=$(grep -oP "undefined symbol: \K.*?(?=[\t,])" <<<"$ldd_resolve"); then
            #drop cached symbols.
            if [[ -v resolved_symbols[@] ]]; then
                undefined_symbols=$(grep -v -f <(IFS=$'\n'; echo "${!resolved_symbols[*]}") <<<"$undefined_symbols")
            fi
            #skip if all symbols in cache.
            [[ -z "$undefined_symbols" ]] && continue
            #package wide symbol resolution.
            scanelf_resolve=$(scanelf -qs "+$(tr $'\n' ','<<<"$undefined_symbols"|sed -e 's/,$//' -e 's/,/,\+/g')" "${files[@]}"|grep -f <(echo "${undefined_symbols}"))
            if [ -n "$scanelf_resolve" ]; then
                for symbol in $undefined_symbols; do
                    if scanelf_resolve_symbol=$(grep -oP "$symbol.*  \K.*" <<<"$scanelf_resolve"); then
                        resolved_symbols+=(["$symbol"]="$scanelf_resolve_symbol")
                    else
                        local_unresolved_symbols+=("$symbol")
                    fi
                done
            else
                mapfile -t local_unresolved_symbols <<<"$undefined_symbols"
            fi
        fi
        if [ -v local_unresolved_symbols ]; then
            #system wide symbol resolution.
            scanelf_resolve=$(scanelf -qpls "+$(IFS=','; echo "${local_unresolved_symbols[*]}"|sed -e 's/,$//' -e 's/,/,\+/g')"|grep -f <(IFS=$'\n'; echo "${local_unresolved_symbols[*]}"))
            if [ -z "$scanelf_resolve" ]; then
                scanelf_resolve=$(scanelf -qlRs "+$(IFS=','; echo "${local_unresolved_symbols[*]}"|sed -e 's/,$//' -e 's/,/,\+/g')"|grep -f <(IFS=$'\n'; echo "${local_unresolved_symbols[*]}"))
            fi
            for symbol in ${local_unresolved_symbols[*]}; do
                if scanelf_resolve_symbol=$(grep -oP "$symbol.*  \K.*" <<<"$scanelf_resolve"); then
                    resolved_symbols+=(["$symbol"]="$scanelf_resolve_symbol")
                else
                    system_wide_unresolved_symbols+=("$symbol")
                fi
            done
            if [ -v system_wide_unresolved_symbols ]; then
                pacman -Qqo "$file"
                echo -e "\nldd $file\nunresolved symbols: ${system_wide_unresolved_symbols[*]}" >> "$log"
                echo -e "\nldd $file\nunresolved symbols: ${system_wide_unresolved_symbols[*]}" >&2
                return 0
            fi
        fi
    done
}

get_broken_ldd_pkgs() {
    export -f get_package_files
    export -f filter_executable
    export -f ldd_detect_broken_files
    export log
    get_unofficial_pkgs |
    parallel ${_terminal_output:+--bar} --will-cite "echo {}|get_package_files|filter_executable|ldd_detect_broken_files"
}

get_broken_python_pkgs() {
    command -v python >/dev/null || return
    python_version="$(python3 -c 'import sys; print (sys.version_info.minor)')"
    pacman -Qqo /usr/lib/python3.!("$python_version") 2>/dev/null
}

get_broken_perl_pkgs() {
    command -v perl >/dev/null || return
    perl_version="$(perl -E 'say $^V =~ /(\d+[.]\d+)/')"
    pacman -Qqo /usr/lib/perl*/!("$perl_version") 2>/dev/null
}

get_broken_pkgs() {
    {
        get_broken_ldd_pkgs
        get_broken_python_pkgs
        get_broken_perl_pkgs
    } | sort -u
}

get_repo_pkgs() {
    pacman -Sl | cut -d' ' -f1-2
    pacman -Qqm | awk '{print "foreign", $0}'
}

join -12 <(get_repo_pkgs | sort -k2) <(get_broken_pkgs) | awk '{ print $2 "\t" $1 }'

if (( verbose )); then
    for f in "$log"/*; do
        cat "$f"
    done
fi

exit 0
